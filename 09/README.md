# Bash

## Написать скрипт для CRON, который раз в час будет формировать письмо и отправлять на заданную почту.

Необходимая информация в письме:
* список IP адресов (с наибольшим кол-вом запросов) с указанием кол-ва запросов c момента последнего запуска скрипта;
* список запрашиваемых URL (с наибольшим кол-вом запросов) с указанием кол-ва запросов c момента последнего запуска скрипта;
* ошибки веб-сервера/приложения c момента последнего запуска;
* список всех кодов HTTP ответа с указанием их кол-ва с момента последнего запуска скрипта;
* скрипт должен предотвращать одновременный запуск нескольких копий, до его завершения;
* в письме должен быть прописан обрабатываемый временной диапазон.

## Реализация

Все работы проводил на Uduntu 22.04.3 LTS Linux 6.2.0-39-generic x86-64.
Скрипт будет парсить файл `access.log` веб-сервера, который находится в `/var/log/"вебсервер"/access.log`
Сложность задачи заключается в выборке строк лог файла за 1 час с момента последнего запуска скрипта.

Для работы скриптов потребуется поместить их в директорию где находится лог файл, запустить команду в папке со скриптами: `mv main_grep.sh post.sh at_hour.sh to_hour.sh rows_at_hour.sh /var/log/"вебсервер"`/
Так же необходимо в папке `/etc/cron.hourly` разместить скрипт `post.cron` который будет запускать скрипт `post.sh` раз в час, и не допускать мультизапуск.
Скрипт `post.sh` производит запуск скрипта `main_grep.sh` и отправляет его вывод на почту.

## 1. Список IP адресов (с наибольшим кол-вом запросов) с указанием кол-ва запросов c момента последнего запуска скрипта.

### Определение времени

Для начала надо определить время, с которого будет производиться выборка строк из лог файла.
Форматирование даты и времени будет с англ локализацией, т.к. в лог файле используется `LANG=en_EN`.
Так как нам необходимо делать выборку строк с момента последнего запуска скрипта и 1 раз в час,
то будем брать за момент последнего запуска скрипта -d '1 hour ago' (текущее время минус 1 час).

Сделаем отдельный скрипт для определения и форматирования даты и времени:

[at_hour.sh](/homework/09/at_hour.sh)

<details><summary>см. at_hour.sh</summary>

```shell
#!/bin/sh
# Функция получения предыдущего часа в формате %d/%b/%Y:%H, который необходим для
# осуществления выборки из лог-файла с датой указанного формата
# Как использовать:
#
#         #!/bin/sh
#         . ./at_hour.sh
#         at_hour=$(hour)
#         echo $at_hour
hour() {
    # local d=$(LANG=en_EN date -d '1 hour ago' +%d/%b/%Y:%H)
    # Так как необходимо производить выборку за предыдущий час из лога,
    # то производится -d '1 hour ago'
    # При этом локаль принудительно LANG=en_EN, иначе генерирует дату в текущей локали
    # Так как мы используем тестовый лог файл, то в нем нет сведений на актуальное время,
    # имитируем выборку в прошлом, для этого вычтем необходимое количество часов 590

    corrective=590
    formatted_hour=$(LANG=en_EN date -d "$corrective hour ago" +%d/%b/%Y:%H)
    echo $formatted_hour
}

```

</details>

### Выборка строк за последний час

Теперь мы знаем дату и время, за которое надо собрать сведения из лог файла.
Делаем скрипт для выборки строк за это время.
Основной принцип состоит в фильтрации лог файла`cat "${_LOG_FILE}" | grep "\[$_AT_HOUR:"`
Где `LOG_FILE` - это список всех строк лог файла, а `AT_HOUR` - фильтр по времени.

[rows_at_hour.sh](/homework/09/rows_at_hour.sh)

<details><summary>см. rows_at_hour.sh</summary>

```shell
#!/bin/sh
. ./at_hour.sh

AT_HOUR=$(hour)

DEBUG=0
if [ "${DEBUG}" = "1" ]
then
  echo SELECT LOG-DATA AT HOUR $AT_HOUR
fi

rows_at_hour() {
    _LOG_FILE=${LOG_FILE}
    _AT_HOUR=${AT_HOUR}
    cat "${_LOG_FILE}" | grep "\[$_AT_HOUR:"
    exit 0
}

```

</details>

### Выборка 10 топ IP адресов

Выборку делаю с помощью конструкции:
`rows_at_hour  | awk '{print $1}' | sort | uniq -c | sort -rn | head -n 10`

Где `rows_at_hour` - это все строки лог файла за предыдущий час,
далее выборка столбца с IP адресами, их группировка и сортировка,
и вывод на экран 10 верхних строк.

## 2. Список запрашиваемых URL (с наибольшим кол-вом запросов) с указанием кол-ва запросов c момента последнего запуска скрипта

Используя выборку строк за предыдущий час `rows_at_hour`, делаем выборку запрашиваемых URL с
помощью конструкции:
`rows_at_hour | awk '{print $7}' | sort | uniq -c | sort -rn | head -n 10`

## 3. Ошибки веб-сервера/приложения c момента последнего запуска

Используя выборку строк за предыдущий час `rows_at_hour`, делаем выборку ошибок
`4**` и `5**` с помощью конструкции:
`rows_at_hour | awk '{print $9}' | grep ^4`
`rows_at_hour | awk '{print $9}' | grep ^5`

## 4. Список всех кодов HTTP ответа с указанием их кол-ва с момента последнего запуска скрипта

Используя выборку строк за предыдущий час `rows_at_hour`, делаем выборку HTTP ответов с
помощью конструкции:
`rows_at_hour | awk '{print $9}'| grep -v "-" | sort | uniq -c | sort -rn`

## 5. Скрипт для CRON, который раз в час будет формировать письмо и отправлять на заданную почту

Собираем все команды в один скрипт:

[main_grep.sh](/homework/09/main_grep.sh)

<details><summary>см. main.sh</summary>

```shell
#!/bin/bash
. ./at_hour.sh
. ./to_hour.sh
. ./rows_at_hour.sh

# дата и время с которого будет выборка
AT_HOUR=$(hour)

# дата и время AT_HOUR + 1 час
TO_HOUR=$(hour1)

# Проверка на переданный параметр
USAGE="Pls, rows_at_hour.sh LOG_FILE"
if [ -z "$1" ]
then
  echo "Sorry, there is no first parameter LOG_FILE."
  echo $USAGE
  exit 1
fi

LOG_FILE="${1}"

DEBUG=0
if [ "${DEBUG}" = "1" ]
then
  echo USE LOG FILE $LOG_FILE
fi

#0
echo "Временной диапазон:" $AT_HOUR "-" $TO_HOUR

#1 URN
echo "Топ-10 клиентских URL запрашиваемых с этого сервера"
rows_at_hour | awk '{print $7}' | sort | uniq -c | sort -rn | head -n 10 > 1.1.txt && cat 1.1.txt &&
echo "------------------------------------------------------"
#2 IP
echo "Топ-10 клиентских IP"
rows_at_hour  | awk '{print $1}' | sort | uniq -c | sort -rn | head -n 10 > 2.2.txt && tail -n 10 2.2.txt &&
echo "------------------------------------------------------"
#3 запросы-ответы
echo "Все коды состояния HTTP и их количество"
rows_at_hour | awk '{print $9}'| grep -v "-" | sort | uniq -c | sort -rn > 3.3.txt && cat 3.3.txt &&
echo "------------------------------------------------------"
#4 ошибки серверные 5** и клиентские 4**
echo "Все коды состояния  4xx и 5xx"
rows_at_hour | awk '{print $9}' | grep ^4 > 4.4.txt && rows_at_hour | awk '{print $9}' | grep ^5 >> 4.4.txt && cat 4.4.txt | uniq -d -c | sort -rn > 4.5.txt && cat 4.5.txt
echo "------------------------------------------------------"
echo "all"
rm -f 1.1.txt 2.2.txt 3.3.txt 4.4.txt 4.5.txt

```

</details>

Результат выполнения скрипта `main_grep.sh`:

[main_grep.log](/homework/09/main_grep.log)

<details><summary>см. main_grep.log</summary>

```properties
Временной диапазон: 03/Dec/2023:22 - 03/Dec/2023:23
Топ-10 клиентских URL запрашиваемых с этого сервера
      2 /wp-login.php?action=register
      2 /logs/access.log
      1 /?q=user
      1 /boaform/admin/formLogin
------------------------------------------------------
Топ-10 клиентских IP
      3 23.229.13.198
      2 159.192.123.2
      1 31.7.58.42
------------------------------------------------------
Все коды состояния HTTP и их количество
      6 200
------------------------------------------------------
Все коды состояния  4xx и 5xx
------------------------------------------------------
all

```

</details>

### Предотвращение мультизапуска

Необходимо в папке `/etc/cron.hourly` разместить скрипт `post.cron`,
который будет запускать скрипт `post.sh` раз в час, и не допускать мультизапуск.

[post.cron](/homework/09/post.cron)

<details><summary>см. post.cron</summary>

```shell
#!/bin/bash

LOCKFILE=/var/log/nginx/post.sh
#LOCKFILE=/var/log/"вебсервер"/x
if [ -f $LOCKFILE ]
then
  echo "Lockfile active, no new runs."
  exit 1
else
  echo "PID: $$" > $LOCKFILE
  trap 'rm -f $LOCKFILE"; exit $?' INT TERM EXIT
  echo "Simulate some activity..."
  rm -f $LOCKFILE
  trap - INT TERM EXIT
fi

```

</details>

[post.sh](/homework/09/post.sh)

<details><summary>см. post.sh</summary>

```shell
#!/bin/bash
sudo su
if

./main_grep.sh ./access.log > report.txt &&
mailx v.kan@gsgroup.it < report.txt && rm report.txt

then
exit 0
else
echo "file not found"
fi

```

</details>

Скрипт `post.sh` производит запуск скрипта `main_grep.sh` и отправляет его вывод
на почту пользователя.
Отправка на почту производится с помощью сервиса `mailx`. Для этого достаточно его установить.
